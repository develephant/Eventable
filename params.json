{"name":"Eventable","tagline":"A series of tubes for Lua tables.","body":"# Eventable\r\n\r\n_A series of tubes for Lua tables._\r\n\r\n__Eventable__ lightly extends your tables to create a \"network\" of tables that can listen for, and send events. Works across modules too. It's basically a chat room for your tables and mods.\r\n\r\n## Install\r\n\r\nPut the `Eventable.lua` somewhere in your project, and require it where ever you need it\r\n\r\n```lua\r\n--== main.lua ==--\r\nlocal Eventable = require('Eventable')\r\n```\r\n\r\n## Usage\r\n\r\nFor a table to be part of the __Eventable__ messaging loop, it must be _evented_ like so:\r\n\r\n```lua\r\nlocal et = require('Eventable')\r\n\r\n--== evented table\r\nlocal tbl = et:new()\r\n```\r\n\r\nYou now have a table that is also part of the __Eventable__ messaging network.\r\n\r\nAs long as you don't use any of the __Eventable__ method names (see below), you can pass in any starting data table.\r\n\r\n```lua\r\nlocal starter_tbl = { username = \"Fred\", age = 55 }\r\nlocal etbl = Eventable:new( starter_tbl )\r\n```\r\n\r\n__Listening for events in the network.__\r\n\r\n```lua\r\n\r\n--== Listening for 'tweet' event\r\nlocal etbl = et:new()\r\netbl:on('tweet', function( evt, message )\r\n  print( 'The '..evt.name..' was '..message )\r\nend)\r\n\r\n--== Sending\r\nlocal starter_tbl = { greeting = \"Hello!\" }\r\nlocal etbl2 = et:new( starter_tbl ) --wrap it\r\n\r\netbl2:emit('tweet', self.greeting )\r\n```\r\n\r\n> `--> The tweet was Hello!`\r\n\r\n__Listening for events once.__\r\n\r\n```lua\r\netbl:once( 'tweet', function( evt, message )\r\n  print( 'tweet: ' .. message )\r\n  print( 'bye tweety!')\r\nend)\r\n```\r\n> `--> tweet Goodbye!`\r\n\r\n> `--> bye tweety!`\r\n\r\nThe event callback will trigger one time, and never again, unless you re-register the `on` handler.\r\n\r\n__Sending events through the network.__\r\n\r\n```lua\r\netbl:emit('my-event', someval, otherval, alotofvals )\r\n```\r\nAfter specifying an event name, you can pass as many arguments as you need, comma separated.\r\n\r\n> __Any _evented_ table can opt-in to listening to any event from any other _evented_ table.__\r\n\r\n```lua\r\nlocal et = require('Eventable')\r\n\r\n--Create some new evented tables\r\nlocal cook = et:new()\r\nlocal waiter = et:new()\r\n\r\n--Cook waits for order\r\ncook:on('order', function( evt, food )\r\n  print('Now cooking'..food)\r\n  -- ...\r\n  self:emit( 'order-up', food )\r\nend)\r\n\r\n--Waiter listens for order\r\nwaiter:on('order-up', function( evt, food )\r\n  print( 'Your ' .. food .. ' are served.')\r\nend)\r\n\r\n--Waiter places order\r\nwaiter:emit('order', 'Pancakes')\r\n```\r\n> `--> Now cooking Pancakes`\r\n\r\n> `--> Your Panackes are served`\r\n\r\n### Communication through modules.\r\n\r\nIn this example, the first two modules are listening for a _greeting_ event. The third module `emits` the event. You might also notice the use of the `once` method, instead of the more common `on`. Usually once your greeted, you don't need to be re-greeted. So here `once` makes sense.\r\n\r\n```lua\r\n--== mod_one.lua ==--\r\nlocal et = require('Eventable')\r\nlocal mod = et:new()\r\n\r\nmod:once('greeting', function( evt, message )\r\n  print( message )\r\nend)\r\n\r\nreturn mod\r\n```\r\n\r\n```lua\r\n--== mod_two.lua ==--\r\nlocal et = require('Eventable')\r\nlocal mod = et:new()\r\n\r\nmod:once('greeting', function( evt, message )\r\n  print( 'this is my greeting: ' .. message )\r\nend)\r\n\r\nreturn mod\r\n```\r\n\r\n\r\n```lua\r\n--== mod_three.lua ==--\r\nlocal et = require('Eventable')\r\nlocal mod = et:new()\r\n\r\nmod:emit( 'greeting', 'Hello!' )\r\n\r\nreturn mod\r\n```\r\n> `--> Hello!`\r\n\r\n> `--> this is my greeting: Hello!`\r\n\r\n### Managing your listening options.\r\n\r\n__Stop listening for a certain event. Other events are unaffected.__\r\n\r\n```lua\r\netbl:off( 'tweet' )\r\n```\r\n\r\n__Stop listening for any and all events.__\r\n\r\n```lua\r\netbl:allOff()\r\n```\r\n> __Once you release events using `off` or `allOff`, you will need to re-register your `on` handler again. You can also use `mute`, which does not remove your events, as shown below.__\r\n\r\n__Temporary silencing of all events. Events are not released.__\r\n\r\n```lua\r\n-- Mute all events\r\netbl:mute( true )\r\n\r\n-- Listen to all events again\r\netbl:mute( false )\r\n```\r\n\r\n__Check if table listening is muted.__\r\n\r\n```lua\r\nlocal trueOrFalse = etbl:isMuted()\r\n```\r\n\r\n## Eventable static methods\r\n\r\nPrint a table into human readable form.\r\n\r\n```lua\r\nEventable.p( tbl )\r\n```\r\n\r\nTo get a count of all the _evented_ tables.\r\n\r\n```lua\r\nlocal count = Eventable.count()\r\n```\r\n\r\nPrint all event names active to the terminal. (needs work)\r\n\r\n```lua\r\nEventable.list()\r\n```\r\n\r\nRelease a table from __Eventable__ messaging loop. You cannot reattach after this action. You must create a new instance. Generally, you shouldn't need to use this action.\r\n\r\n```lua\r\nEventable.release( etbl )\r\n```\r\n\r\n# Eventable API\r\n\r\nThe following methods are available on any _evented_ table. Please do not overwrite them.\r\n\r\nYou can call methods directly on the _evented_ table object, or through using `self` internally.\r\n\r\n```lua\r\nlocal etbl = et:new()\r\netbl:emit('party', 'tonight')\r\n```\r\n```lua\r\nlocal etbl = et:new()\r\netbl:goParty = function(when)\r\n  self:emit('party', when)\r\nend\r\netbl:goParty('tonight')\r\n```\r\n\r\n## Methods\r\n\r\n### :new([starting_table])\r\n\r\nCreates a fresh _evented_ table. This table can message with other  _evented_ tables and mods. Can optionally take a `starting_table` that will become 'wrapped' into an _evented_ table.\r\n\r\n```lua\r\nlocal et = require('Eventable')\r\n\r\nlocal etbl = et:new()\r\n-- or\r\nlocal etbl = et:new( { username = \"Bob\" } )\r\n```\r\n\r\n---\r\n\r\n### :emit( event_name, ... )\r\n\r\nBroadcast data parameters to any other _evented_ tables listening for this `event_name`.\r\n\r\n```lua\r\nlocal et = require('Eventable')\r\n\r\nlocal etbl = et:new()\r\netbl:emit( 'greeting', 'Good Day!')\r\n```\r\n\r\n---\r\n\r\n### :on( event_name, callback )\r\n\r\nListens for a specific event name to be emitted, and take action with the callback. The callback will return an `event` object and any other arguments available.\r\n\r\nIn the `event` object you can find the event `name` and `target` key, which points to the table that triggered this event.\r\n\r\n```lua\r\nlocal et = require('Eventable')\r\n\r\nlocal etbl = et:new()\r\netbl:on('greeting', function( evt, message )\r\n  print( message )\r\nend)\r\n```\r\n\r\n---\r\n\r\n### :once( event_name, callback )\r\n\r\nListens for a specific `event_name` to be emitted, and take action with the callback _only one time_, and no more.\r\n\r\n```lua\r\nlocal et = require('Eventable')\r\n\r\nlocal etbl = et:new()\r\netbl:once('greeting', function( event, message )\r\n  print( message )\r\n  print( 'Bye bye!')\r\nend)\r\n```\r\n\r\n> Something like a \"greeting\" is a good candidate for using `once`, since you only greet someone one time each session.\r\n\r\n---\r\n\r\n### :off( event_name )\r\n\r\nStop listening for the specified `event_name`. Once a event is turned off, it can only be added as a new `on` instance. See the `mute` method for an alternative.\r\n\r\n```lua\r\netbl:off( 'greeting' )\r\n```\r\n> Will no longer listen for the _greeting_ event.\r\n\r\n---\r\n\r\n### :allOff()\r\n\r\nRemoves all events from the table / mod. This table will only get the 'global' event.\r\n\r\n```lua\r\netbl:allOff()\r\n```\r\n> Will no longer listen for the _any_ events.\r\n\r\n### :mute( trueOrFalse )\r\n\r\nMutes all event input while enabled. Event listeners are left active unlike `off` or `allOff`.\r\n\r\n```lua\r\netbl:mute( true ) --no events read\r\n\r\n-- or\r\n\r\netbl:mute( false ) --read events again\r\n```\r\n> Toggle mute for all events. But listeners will remain.\r\n\r\n### :isMuted()\r\n\r\nChecks whether the _evented_ table is `muted`. Will return true or false.\r\n\r\n```lua\r\nlocal is_muted = etbl:isMuted()\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}